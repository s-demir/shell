# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    note.txt                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: sedemir <sedemir@student.42.fr>            +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/07/31 16:37:44 by sedemir           #+#    #+#              #
#    Updated: 2025/08/05 16:46:52 by sedemir          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "minishell.h"

int					g_var_thing;

// DÜZELTME: Function declaration'ları yukarı taşıdık
static int process_node(t_ast_node *head, int *piped, t_env *env, int *fd);
static int process_redir(t_ast_node *head, int *piped, t_env *env, int *fd);

int	handle_piped_cmd(t_ast_node *head, int *_piped, t_env *env, int *_fd)
{
    int				fd_[2];
    int				status;

    // Pipe oluştur - başarısızlık durumunu kontrol et
    if (pipe(fd_) == -1)
    {
        fd_[0] = -1;  // Hata durumunda güvenli değerler ata
        fd_[1] = -1;
        return (1);
    }

    status = fork();
    if (status == 0)  // Child process
    {
        child_fds_managment(_piped, _fd, fd_);
        status = process_node(head, _piped, env, _fd);
        exit(status);
    }
    else if (status > 0)  // Parent process
    {
        parent_fds_managment(_piped, _fd, fd_);
        _piped[PIPE_ACTIVE]++;
    }
    else  // Fork başarısız
    {
        close_pipe_fds(fd_[0], fd_[1]);  // Pipe fd'lerini temizle
        return (1);
    }

    return (status);
}

static int process_redir(t_ast_node *head, int *piped, t_env *env, int *fd)
{
    int				status;

    status = open_file_for_redirection(head, piped, env, 0);
    if (status)
        return (status);
    return (process_node(head->left, piped, env, fd));
}

int manage_redir(t_ast_node *head, int *piped, t_env *env, int *fd)
{
    if (head->file_type >= READ_FILE && head->file_type <= WRITE_FILE_APPEND)
        return (process_redir(head, piped, env, fd));
    else
        return (process_node(head, piped, env, fd));
}

// DÜZELTME: Orijinal logic'inizi koruyarak sadece TOKEN türlerini kullandık
static int process_node(t_ast_node *head, int *piped, t_env *env, int *fd)
{
    int status;

    if (head->type == TOKEN_PIPE)
        status = handle_piped_cmd(head, piped, env, fd);
    else if (head->type == TOKEN_REDIR_IN || head->type == TOKEN_REDIR_OUT ||
        head->type == TOKEN_REDIR_APPEND || head->type == TOKEN_REDIR_HEREDOC)
        status = manage_redir(head, piped, env, fd);

    return status;
}

// DÜZELTME: Ana execution fonksiyonu - sadece fd temizliği eklendi
int execute_ast_node(t_ast_node *head, int *piped, t_env *env)
{
    int fd[2];
    int status;

    // Fd'leri güvenli değerlerle başlat
    fd[0] = -1;
    fd[1] = -1;

    // Node tipine göre işlem yap (ORİJİNAL LOGİC KORUNDU)
    if (head->file_type == FILE_READY)
        status = process_node(head, piped, env, fd);
    if (head->file_type == EXECUTE_FILE)
        status = prep_run_cmd(head->args, fd, piped, env);

    // Child process'leri bekle
    status = wait_children(status, piped);

    // SADECE FD TEMİZLİĞİ EKLENDİ - Logic değişmedi
    cleanup_redirection_fds(piped);
    close_pipe_fds(fd[0], fd[1]);

    g_var_thing = 0;
    return status;
}
